<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      class MyPromice {
        constructor(fn) {
          // console.log(fn,'fn');

          this.status = "pending";

          this.okFun = [];

          this.failFun = [];

          let resolve = (val) => {
            if (this.status == "pending") return;

            this.status = "success";

            setTimeout(() => {
              this.okFun.forEach((item) => item.call(this, val));
            });
          };

          let reject = (err) => {
            if (this.status == "pending") return;

            setTimeout(() => {
              this.failFun.forEach((item) => item.call(this, err));
            });
          };

          try {
            fn(resolve, reject);
          } catch (err) {
            reject(err);
          }
        }
        then(okCb, errCb) {
          okCb = typeof okCb !== "function" ? (v) => v : okCb;
          errCb =
            typeof okCb !== "function"
              ? (err) => {
                  throw err;
                }
              : errCb;

          // 链式调用
          return new MyPromice((resolve, reject) => {
            this.okFun.push((val) => {
              console.log("222", val);
              try {
                let x = okCb(val);
                // 难点：如果回调函数是普通值，那么就resolve出去给下一个then链式调用，
                // 如果是一个promice对象,个promise对象（代表又是一个异步） 那么调用x的then方法 将resolve和reject传进去
                // 等到x内部的异步 执行完毕的时候（状态完成）就会自动执行传入的resolve 这样就控制了链式调用的顺序
                x instanceof MyPromice ? x.then(resolve, reject) : resolve(x);
              } catch (error) {
                reject(error);
              }
            });

            this.failFun.push((val) => {
              try {
                let x = errCb(val);
                x instanceof MyPromice ? x.then(resolve, reject) : reject(x);
              } catch (error) {
                reject(error);
              }
            });
          });
        }
      }

      let p1 = new MyPromice((resolve, reject) => {
        setTimeout(() => {
          resolve("123");
        });
      });

      p1.then((res) => {
        console.log(res, "res");
      });

      let arr = [];
      let obj22 = {name:'123'}

      for (const a in obj22) {
        console.log(a,'a');
      }

      console.log(arr.length && '1111');
      console.log(obj.length && '2222');

      function deepClone(data) {
        if (typeof data != "object") return data;
        let cloneData = obj.length == 'undefined' ? {} : []
        for (const key of data) {
          console.log(a, "a");
        }
      }
    </script>
  </body>
</html>
